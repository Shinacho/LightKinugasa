# LIGHT KINUGASA GAME ENGINE
これは私のゲームエンジン、通称「軽衣笠」の使い方をカンタンに書いたものです。

まずは軽衣笠の由来について少し説明しましょう。
これはもともと、2011年に当時20歳の私が作り始めた「衣笠ゲームフレームワーク」でした。
私は根っからの「天外魔境２」ファンであり、そのようなゲームを自作したいと思って、自分でフレームワークとゲーム本体を作ることにしたのです。
私は毎日想像を絶する学習・設計・製造を続け、初心者の状態から50回以上の作り直しを経て、衣笠を何とか稼働できるレベルまで仕上げました。私は本職がSEですが、ゲーム開発会社の社員ではないので、これらは独学で作ったものです。
しかし、私のゲームに必要な要素を実装していった衣笠は、まるでサイコガンダムのように巨大化し（ゲームフレームワークがデカすぎる！）、今では約7万ステップを超え、もはや汎用ゲームエンジンとゲーム本体を切り分けるという当初の設計思想の達成が難しくなっていました。
そこで、私のゲーム用に書いたロジックをバッサリカットして、汎用的な処理だけをのせているのが、この「軽衣笠」です。

ちなみにゲーム本体は今でも開発を続けており、これを書いている今はストーリーを全部書ききったので、まずは原作小説を出版して商標を取るのを目標に動いています。2030年までにゲーム本体が完成するといいなぁ。

## それで、これは何？
フレーム数ベースで動く2Dゲームを作るためのフレームワークです。
元はRPG用ですが、「軽」ではかなりの機能をオミットしているので、シューティングゲームくらいが作れると思います。
RPG用の機能は、順次搭載しています。
現時点では、フィールドマップの表示や移動、NPCとの会話ができます。戦闘システムやアイテム、宿などはまだ作ってません。

### 特徴
* JavaSEしか使ってません。面倒なライセンス管理ナシ！使い方もawt/Swing準拠で簡単！
* MITライセンスで商用非商用問わず自由に使えます。改変も可能です。ただしもとのコピーライトは消さないでね。

### 環境
このフレームワークはJava17でコンパイルしています。17以上で使ってください。
単にjarをあなたのプロジェクトに追加すれば、おそらく使えるでしょう。[モジュールシステムに対応しています。](src/module-info.java)

### 機能
* FPSを指定してゲームを実行でき、ループ処理を記載せずとも動きます
* キーボード、マウス、USBゲームコントローラー（Windows 64Bitのみ）が使えます
* テキスト、画像、メッセージウインドウなどを表示できます
* サウンドの再生ができます
* フィールドマップ（CSVから構築するスクロール可能なイメージ）を構築して表示できます。
* NPCと会話できます。
* I18N機能を実装しており、iniファイル等から翻訳テキストを取得できます。

## 基本構造
衣笠は、[GameManager](src/kinugasa/game/GameManager.java)を中心に動きます。
GameManagerを継承したクラスにMainを作って、そこをエントリポイントとして動きます。
GameManagerには、初期化・終了処理と、自動的にループで呼び出される更新・描画処理の4つがあり、これを実装することであなたのゲームを動かします。
具体例は[サンプル実装](src/kinugasa/game/sample/Test.java)を見てください。

## GameManagerの解説
GameManagerを継承したクラスの解説をしましょう。
この継承クラスに必要なのは、最低6つのメソッドです。
1. main：通常のメインメソッドですが、そのクラスをインスタンス化してgameStart()をコールしてください。また、このフレームワークにはゲームの二重起動を防止する仕掛けが入っているので、それを無効化するために、開発中は最初にロックファイル削除を実行しておくとよいでしょう。具体例は上記のサンプルを見てください。
2. コンストラクタ：コンストラクタではsuper(GameOption)を実行します。[GameOption](src/kinugasa/game/GameOption.java)は普通にインスタンスを作ってもよいですし、INIFileなどを使ってGameOptionValueのインスタンスを生成すれば、ファイルからも読めるでしょう。ゲームパッドを使いたい場合はここでsetUseGamePad(true)を実行してください。
3. startUpの実装：このメソッドはgameStartが実行されると1回だけ実行されるものです。この時点ではウインドウが表示されていません。なので、例えばBGMのロード再生といった初期化処理を書きます。ウインドウが表示されていないので、ウインドウのサイズなどをとれない点に注意してください。サイズはstartUpの処理が終わると、getWindow().getInsets()で取れます。
4. disposeの実装：このメソッドは、gameExitが実行されると1回だけ実行されるものです。gameExitは明示的に実行してもいいですし、デフォルトではウインドウが閉じられると実行されます。したがって、ここにはファイルを解放したりセーブする処理を記述します。
5. updateの実装：このメソッドは、GameOptionで指定したFPSの周期でループ実行されます。引数は[GameTimeManager](src/kinugasa/game/GameTimeManager.java)通称gtmと、[InputState](src/kinugasa/game/input/InputState.java)通称isがあります。gtmからはFPSや総経過時間を取得でき、isではキーやマウス、コントローラーの入力を検知できます。
6. drawの実装：このメソッドは、GameOptionで指定したFPSの周期でループ実行されます。引数は[GraphicsContext](src/kinugasa/graphics/GraphicsContext.java)で、ゲーム内オブジェクトを描画する処理を記述します。drawの順序に注意してください。あとに書いたものが上に表示されます。上書きされるということです。下に書いたものは見えなくなります。

常に、update→drawの順で実行されます。これはシングルスレッドで実行されています。そのため、同一のリストを参照してどちらの処理も実行することができます。drawの中で更新を行ってもほとんどの場合問題はないですが、役割をわかりやすくするためにオブジェクトの更新処理と描画処理を分けて記述するべきでしょう。一部のアニメーションの自動再生などは、drawの中で更新をしている場合があります。

## 描画系の機能
ここでは、あなたのゲーム制作に役立つ機能を紹介しましょう。

### Sprite
Spriteは画面に描画する物体の個体です。
様々な派生クラスがあり、どれも共通して描画が可能です。

### ImageSprite
ImageSprite画像を表示するためのSpriteの実装です。画像はKImageを使います。

### KImage
KImageは編集可能な画像の個体です。しかし編集は重いので、ゲーム中にあまり実施すべきではないでしょう。ロード時等に行うとよいと思います。KImageはGraphics2Dを使って何かを描画したり、ファイルから読み込むことができます。推奨のファイル形式はpngで、透過画像も使えます。

### AnimationSprite
AnimationSpriteはImageSpriteの拡張で、複数の画像をアニメーション再生できるSpriteです。SpriteSheetを使って、1枚の画像から特定のサイズで切り出してアニメーションを作ることができます。もちろん、KImageの集合から作ってもよいです。

### WalkAnimation
WalkAnimationは、4方向のアニメーションを持っている、いわゆる歩行グラフィックです。CharaSpriteで使います。

### TimeCounter
TimeCounterは一定周期で何かを発動したいときに使うカウンタです。例えばアニメーションの再生速度を定義するのに使います。一番よく使うのはFrameTimeCounterでしょう。これは単純に何フレームおきにそのイベントを起こすかを定義するものです。例えばアニメーション再生速度に12を指定したら、12フレームおきに次の画像に切り替わる、ということです。

### KVector
KVectorは角度と移動速度を持つクラスです。Spriteが持っています。Spriteのmoveを実行すると、このKVectorに基づいて移動します。simulateMove機能を使って、移動後の座標を計算して、移動範囲を制限することができます。その具体例はサンプル実装を見てください。

### TextLabelSprite
TextLabelSpriteは1行のテキストを表示するためのSpriteです。TextLabelModelやFontModelを使用してフォントなどを指定できます。その具体例はサンプル実装を見てください。
フォントのインスタンスに注意してください、1つのModelを更新すると、同じインスタンスを使う別のテキストもフォントが変わります。FontModelは常にcloneするとよいでしょう。

### MessageWindow
MessageWindow複数行にわたるテキストを表示するためのスプライトです。さらに、1文字ずつ表示したり、その速度を制御したり、次のテキストがあることを示す記号を表示する機能もあります。メッセージウインドウの見た目はデフォルトではサンプル実装のような見た目ですが、MessageWindowModelを使って変更することができます。
MessageWindowに表示するテキストは、StringではなくTextというクラスを使い、これはI18Ntextから生成できます。つまり翻訳結果を表示できます。デフォルトでは、`<br>`という文字が改行になります。自動改行はありませんので、適切に指定する必要があります。これをI18Nに仕込むことで改行できます。

### Dialog
DialogはJOptionPaneを使って簡易なダイアログを出すものです。


## データ系
### Storage
StorageはIDに対して何らかのオブジェクトをメモリ上に置くためのマップです。HashMapのようなものです。いろいろな場所で使います。

### File
File関連のクラスは、テキスト、CSV、ini、XMLが使えます。これらはクラスが分かれており、共通して、ファイルパスを送れば開けます。開いた後は、load()をしてください。不要になったら、dispose()で解放できます。これらはメモリをたくさん使うゲームのために（Javaでは若干不利ではありますが）ロードタイミングと解放タイミングを指定できるようにしているものです。一部のファイルは保存もできます。作りかけで保存機能がまだできていないものがあります。
DataFileという独自の形式も使えます。これはfield4などの定義で多用されていて、中身は単純なテキストです。
DataFileは、#はコメントです。{}で囲った領域をブロックまたはエレメントと呼びます。それ以外の値は、テキストかkey=valueで定義します。
各ブロックには必ず名前がありますが、ブロック外に情報を定義する場合もあります。
```
# コメント
ブロック={
　内容
}
```
という形式です。名前の後の=の書き忘れに注意してください。
DATA==という特殊な書き方は、その後がCSVなどの特殊な連続したデータであることを示します。
DataFileに記述するスクリプトの引数は、""で囲む必要があります。

### 例外について
衣笠フレームワークでは、例外はほぼすべてRuntime例外です。これは、主にtry-catchを書くのが面倒という理由でそうなっています。
そもそもゲームでは例外＝バグで排除すべきものなので、あまり例外を使わないでしょ、という設計思想となっています。
例えばリソースのpngファイルがなくて画像を表示できないなどは、明確なバグであり、排除されているべきなので、すべてRuntimeで差し支えない、と私は思っています。


## 入力系
InputStateから行えます。
入力状態は、現在のフレームと前のフレームの状態があります。前のフレームでも押されていて、今のフレームでも押されている場合は、CONTINUEと呼ばれます。前のフレームで押されておらず、今のフレームで押されているのはSINGLEと呼ばれます。
1回だけ検知したい場合はSINGLE入力を調べ、押し続けて何かを実行する場合はCONTINUEで検知します。いずれも、InputStateから調べることを推奨しますが、InputStateから取得した下記のような各クラスから直接調べることもできるでしょう。入力状態は毎フレーム新規に作成されるインスタンスであり、その各フレームでの状態はfinalな値です。

### キーボード
キーボードの入力検知はKeyStateから行います。KyeStateにKeysでキーを指定すると、そのキーの状態を判定できます。

### マウス
マウスの入力検知は、MouseStateから行います。ボタンの状態を持っていますので、そこから判定してください。

### ゲームパッド（USBコントローラー）
USBコントローラの検知は、GamePadStateから行います。
これにはボタンの状態と、スティックやトリガーの位置が格納されています。スティックはPoint2D.Floatで、-1,0f～中心が0,0、～1.0fの座標で表されます。これはBasicSpriteが持っているControllableのmoveメソッドに渡すと、そのまま移動に使えます。
Gamepadについてもう少し解説しておきましょう。まず、コントローラのレイアウトはXBOXコントローラです。ボタンの数や名前はXBOXコントローラ準拠です。
そして使用できるコントローラも、XBOX準拠です、具体的には、DirectXのXInputをJNIで接続して使っています。なので、例えばPS5のコントローラなどはそのままでは使えません。プレイヤーがSteamにあるDSXといったソフトを使えば、PS5コントローラも使えるでしょう。
GameOptionでゲームパッドを使うと指示すると、GamePadConnectionクラスがdllをロードします。dllがWindows64bit用でしかコンパイルしていないので、それ以外の環境では起動が失敗するでしょう。ゲームパッドを使用しない場合はGameOption#setUseGamePad(false)を実行すると、ほんの少しだけパフォーマンスが改善します。これはデフォルトの設定です。GamePadの入力を調べる時間が不要だからです。

## サウンド
Soundがサウンドの1ファイルに対応します。再生できるのは、wav形式です。wavは実はいろいろな種類があるので、再生できない場合があるかもしれません。
* サウンドをインスタンス化したら、load()してください。このフレームワークでは、サウンドはロードするとそのすべてがメモリに置かれます。すなわちロードはかなり重い処理です。これはサウンドを完璧にループ再生するためにこうなっているものです。setLoopPointからループ位置を指定できます。サウンドのタイプはSEなのかBGMなのかを示すもので、検索などで使えそうなのでつけているものですが、適当に設定しても特に問題はないです。
* サウンドのボリュームの設定ははsetMasterGainから行ってください。0.0fがミュート、1fが通常の音量です。より高い値も指定できます。
* ポーズとは再生を一時停止することです、再生位置は保存され、再度再生を開始するとそこから開始します。
* 停止とは、再生を完全に停止して再生位置をゼロに戻すことです、再度再生を開始すると、サウンドの最初から再生されます。停止してもメモリから解放されません。メモリから解放するにはdispose()を実行してください。
* サウンドの位置はフレームという単位です。これは44.1KHzのサウンドなら1秒に44100フレームあるということです。
* フェードアウトを設定することができます。フェードアウトを設定したサウンドは、SoundSystem#updateを毎フレーム実行しなければ、それが反映されません。GameManagerを継承したあなたのゲームのメインクラスで、updateを実行してください。再生されていないサウンドのupdateは何も実行しないので、フェードアウトを使うのであれば、とにかく毎回SoundSystem#updateを実行すればいいでしょう。フェードアウトを使わない場合は不要です。
* サウンドは、SoundSystem#initを実行すると、その中にあるwavが自動的にSoundSystemに追加されます。フォルダ内は、再帰的に探索されます。その後、サウンドのファイル名の拡張子を除いた部分をIDとして指定して、サウンドを取得します。
* サウンドのID3v2.3タグのTXXX領域にCSVを記述すると、Sound.Type、マスターゲイン、ループ設定を定義できます。

<img width="807" height="547" alt="image" src="https://github.com/user-attachments/assets/025d4692-ddb1-4d2b-a845-25198212b535" />


## I18N
I18Nとは国際化のことで、簡単に言えばゲーム内のテキストを翻訳することです。
I18Nを使うには、あなたのゲームの起動時にGameOptionでI18Nを読み込む処理を渡す必要があります。それは通常IniI18NReaderというクラスを使い、データはINIファイルに書かれますが、別の手段（例えばDB）を作ることもできます。
I18Nのより簡単な利用方法は、I18NTextを使うことです。これは単純にキーを送れば、現在のI18Nの設定を用いて翻訳をtoString()で入手できるものです。

### I18Nの構文
I18Nテキストは、特殊文字があります。
* &{n}：nは0以上の数値です。これはI18NText#setを使うと値をセットできる変数部分です。たとえば「${0}は${1}を手に入れた！」に名前とアイテム名を送れば、それが反映された「卍丸はそば団子を手に入れた！」になります。1つの文中の同じ数値箇所は、同じ値になります。すなわちsetに送った引数の順番です。
* ${methodName("引数")}：これはスクリプトを起動する構文で、最終結果がStringである必要があります。起動できるメソッドは、ScriptAccessObjectにあるメソッド及びそこから呼びだすことができるメソッドです。複数行は定義できず、必ず1行で処理が完結している必要があります。メソッドチェーンが使えます。
* 　例： `サウンド${soundOf("test1").getFile().getId()}の名前は、${soundOf("test1").getFile().getName()}です`
* サンプル実装では、IniI18NReaderを使って、data/i18n.iniをロードしています。


## イベントスクリプト
フィールドマップの解説をする前に、イベントスクリプトについて解説しなければなりません。
Kinusagaのイベントスクリプトは、ScriptSystemというクラスを介してアクセスし、その実体はファイルに記述されたリフレクション処理です。
すなわち、Kinugasaで用意している機能がほぼ使えます。
スクリプトはDataFile形式で、あらかじめ指定されたブロックに処理を記述します。処理の構文はJavaと大体同じです。
* ファイルコールとは、@scriptName("引数")の形で記述するもので、これは別ファイルを呼び出すことを表します。
* PARAMとは引数の名前で、その名前はそのファイル中で識別しとして利用できます。識別子を引数に指定するとき、""で囲む必要はありません。
* IF-ENDIFが使えます。ただし、面倒なのでいくつか制約があります。
　・IF( 条件式 )<改行> 処理<改行> ENDIFの順が必要です。
　・END IF、END_IF　等ではありません。ENDIFです。
　・条件式はメソッドチェーンが使えますが、最終結果がbooleanである必要があります。
　・条件式中の||はORと解釈されます。
　・AND条件を記述するには、&&ではなくIFブロックをネストします。
* スクリプトから呼び出されるメソッドの引数は、UniversalValueである必要があります。可変長引数には対応していません。
* スクリプトが実行できるメソッド（すなわち実行時のthis）は、ScriptAccessObjectクラスにあるメソッドです。ScriptAccessObjectから取得したオブジェクトに対する呼び出しは可能です。
* 変数の定義や代入はできません。（PARAM以外）
* ブロック指定とは、ファイルコール時に実行するブロックを指定する記法で、@fileName("引数").ブロック名 と記述します。記載を省略すると、MAINが実行されます。
* 1ファイル中のブロックから、そのファイルの別のブロックを呼ぶことはできません。

### スクリプトのブロック
スクリプトに記述するブロックは、通常はScriptBlockTypeと同一の名前が必要です。
ただし使用しないブロックは記述を省略できます。
* MAIN：これはブロックを省略した場合に呼び出されるブロックです。
* STEP_ON：これはフィールドマップのタイルに設定されたイベントで、そのタイルに乗ったときに発動するものです。FieldMapSystem#setLocationを実行したときも起動します。
* STEP_DOWN：これはフィールドマップのタイルに設定されたイベントで、そのタイルから外れたときに実行するものです。ただし、マップ変更イベントが実行されたときにそれまで乗っていたタイルのSTEP_DOWNは実行されません。
* APPROACH：これはNPCが持つイベントで、自キャラがNPCと隣接する8マスに乗ったときに発動するものです。
* LEAVE：これはNPCが持つイベントで、自キャラがNPCと隣接する8マスから外れたときに発動するものです。
* TOUCH：これはNPCが持つイベントで、自キャラがNPCに衝突したときに発動するものです。シンボルエンカウント用です。
* TALK：これはNPCが持つイベントで、自キャラがNPCの方向を向いてプレイヤーが話すボタンを押したときに発動するものです。
* MANUAL：これは上記以外の場合に使用できる、手動実行を想定したブロックです。
* PARAM：このブロックはScriptBlockTypeに書いてありません。ここにはPARAMを定義します。書くのは1行に1つの名前だけです。名前は、ほかのブロックで識別子として利用でき、ファイルコールした場合の引数がその順の通りに設定されます。
戦闘システムや店、宿などブロックがないため、今後追加される予定です。

### stdスクリプト
stdスクリプトとは、data/scriptフォルダーに入っているスクリプトで、標準ライブラリのようなものです。
マップ遷移やBGM再生を定義してあります。

### スクリプトの登録とロード
スクリプトは登録されている必要があります。
あなたのゲームの開始直後に、ScriptSystem#initにディレクトリを送れば、その下にあるすべてのks.txtファイルがスクリプトとして登録され、この6文字の拡張子を除いた名前で取得できます。
スクリプトは実行前にロードする必要がありますが、たいていの場合は実行時に自動的にロードされているはずです。


例として、std_ChangeMapNoSoundスクリプトを見て見ましょう。これはフィールドマップのタイル上のある座標から起動することで、別のフィールドマップに移動できるものです。

```
# std_FieldMapChange
# 指定されたパラメータに基づいて、フィールドマップ間の移動を行います。

PARAM={
	nextID # fieldMap.id
	x # int
	y #int 
	dir #FourDirection
	tooltip #I18NText
	
}


#------------------------------------------------

MAIN={

}


STEP_ON={
	setNode(nextID, x, y, dir, tooltip);
	
}

STEP_DOWN={
	unsetNode();

}

TOUCH={

}

APPROACH={


}

LEAVE={
}


TALK={
}

MANUAL={

}
```

まず先頭2行はコメントです。
PARAMブロックでは、このスクリプトで使う引数を定義しています。名前だけなので、コメントで何に解釈されるかを記載しています。
MAINなど空のブロックは未使用で、記述しなくても構いません。
STEP_ONブロックでは、ScriptAccessObject#setNodeを実行しています。これはフィールドマップの遷移パラメータをセットする処理です。
そしてSTEP_DOWNでは、ScriptAccessObject#unsetNodeを実行しています。これはフィールドマップの遷移パラメータを削除する処理です。
Nodeがセットされている状態で、プログラムがFieldMapSystem#changeMapを実行すると、マップが切り替えられます。
切り替えた先のマップのロードが完了すると、フィールドマップのLoadScriptが起動します。


## field4
field4とは、正方形のタイルを並べてフィールドマップを形成するシステムのことです。

### フィールドマップの基本構造
フィールドマップは、CSVデータですが、その内容は3次元のレイヤーによって構成されています。
各レイヤーがCSVで、重なって表示されているとイメージしてください。実際にはもう少し複雑です。
* フィールドマップの実体は、FieldMapクラスですが、これはFieldMapSystemを介してアクセスします。
* フィールドマップ内にはレイヤーがあります。
　　・ベースレイヤー：海などを表示するための1レイヤーで、アニメーション可能な埋め立てられるレイヤーです。
　　・ノーマルレイヤー：地形や建物を表示する複数のレイヤーです。
　　・フロントレイヤー：雲や雨などを表示するための1レイヤーで、アニメーション可能な1枚絵のレイヤーです。これはCSVではなく1枚の大きな画像が表示されます。
* 各レイヤーは、FieldMapCameraを介して動かされます。キャラクターはFieldMapSystem#setLocationで指定されたタイル状の場所で開始し、FieldMapSystem#moveでマップレイヤーまたはキャラが動きます。マップレイヤーのサイズが画面サイズより小さい場合、マップは中央に表示され、レイヤーは移動しません。マップレイヤーのサイズが画面サイズより大きい場合、レイヤー外が表示されないようにマップまたはキャラが移動します。
* フィールドマップの関連データ定義
　　・MapChip/MapChipSet：これはノーマルレイヤーで使うタイルの画像とChipAttributeを定義するためのクラスです。
　　・MapChipAttribute：これはそのタイルの属性を示すもので、「山」「平地」「町」などがあります。これはエンカウントカウンタの処理や、歩行で乗れないが乗り物で乗れるといった判定をするためにあります。
　　・Vehicle：これは現在の移動手段で、Vehicleに登録されたMapChipAttributeに限り、そのキャラはそのタイルに乗れます。
　　・D2Idx（重要）：これはタイル状の位置を表す座標で、xとyを持ちます。32×32マスのフィールドマップでは、一番左上のタイルが0,0、一番右下のタイルが31,31です。これはPointクラスを使うとGUI上の座標と混同するために分けられました。

### フィールドマップのデータ定義
フィールドマップのデータは、すべてファイルに定義します。必要なファイルは以下の通りで、dataフォルダを見ればサンプルが書いてあるでしょう。

#### データ構造
・フィールドマップはマップごとにフォルダが必要です。それ以外のデータは、フィールドマップと混同しなければ、どこにあっても構いません。
サンプル実装では、画像のような構成になっています。

<img width="466" height="444" alt="image" src="https://github.com/user-attachments/assets/cb12fd2c-6517-4763-89c2-875462e12778" />

* chipSet
　これはチップセットを定義するための情報で、画像本体とDataFile形式の定義ファイルを記述します。
　定義ファイルには、画像と切り出しサイズ、そして切り出した1枚1枚のインデックスに対するMapChipAttributeを定義します。
　インデックスは6桁で、YYYXXX形式です。これは、[platinumマップエディタ](http://www.hyperdevice.org)のType1CSVを、FieldMapResourceUtilクラスを使って変換できます。
* フィールドマップフォルダ
　・まず、フォルダ名はFieldMap自体のIDです。
　・内部はDataFile形式のFieldMap定義ファイルと、npc/フォルダがあります。npcフォルダには、そのマップで使うNPCとその一覧を入れます。
* フィールドマップデータファイル
　・このデータファイルが、フィールドマップの本体です。
　　・debugMode=true/false：これはフィールドマップのデバッグ表示のスイッチです。
  　・LOAC_SCRIPT：このブロックは、スクリプトを呼び出すもので、フィールドマップの切替や初期設定でロードが完了したときに1回だけ実行されます。例えばBGMを切り替える処理をここに書きます。
  　・EVENT：このブロックは、フィールドマップのタイル数ベース位置（つまりD2Idx）ごとに1つ設定できるイベントスクリプト呼び出しを書きます。ここで使えるのはファイルコールだけです。つまり@scriptName("引数")です。
  　　stdイベントを起動する場合はそれを呼び出すだけですが、独自の会話イベントなどを作りたい場合は、別のファイルにイベントスクリプトを書いて、ここで呼び出せばよいでしょう。
  　　ここに登録したスクリプトは、STEP_ONとSTEP_DOWNが自動実行されます。
* MINIMAP_LABELはFieldMapSystem#createMiniMapを実行したときにその上に記述するテキストです。フィールドマップのタイル状の位置を指定し、右辺はI18NTextです。
* BACK_LAYERは1つだけ指定できます。
* NOMAL_LAYERは複数記述できます。下に書いたものが、上書きされます。つまり上に書いたレイヤーを表示するために、下のレイヤーは透明なMapChipを持っている必要があります。above=trueを指定すると、そのレイヤーは記述順序を保って、キャラより上に書かれます。屋根などをこれで描画します。
* ANIMATION_LAYERは複数定義できるアニメーションで、場所をタイル位置で指定します。1タイル上で動くことが想定されていますが、おそらくそうでないサイズのアニメーションも再生できるでしょう。（あまりテストはしていません）
* FRONT_LAYERは1つだけ定義でき、雲などのエフェクト画像と移動速度や透過度を指定します。


### NPC
NPCは特殊なスクリプトファイルです。
内容はDataFileで、会話などはすべてスクリプト制御です。
NPCはフィールドマップが持っており、npcListというテキストファイルに座標とIDが書いてあります。
この定義ファイルに基づいてNPCが配置されます。
フィールドマップのfree（つまりマップ変更による別マップへの移動等）が行われると、現在フィールドマップインスタンスが持っているNPCの初期位置とIDはnpcListにまた書き込まれます。
つまり、NPCをほかのフィールドマップに追放するには、npcデータファイルをほかのフォルダに移動して、フィールドマップインスタンスからも消した状態でマップ移動をすればOKです。

サンプルとしてM002マップに住んでる、NPC002君の定義を見て見ましょう。

```
# NPC
# VisibleNameIDInjector

PI={
	speakerImage=data/image/faceImage.png
	named=false

	waTime = 6
	sprite=data/image/npc001.png

	moveModel = ROUND,1,1f
}

TOUCH={

	openMessageWindow("T007").byMe();
	closeMessageWindow();
}

TALK={

	openMessageWindow("T001").byMe();


	nextText("T002");
	nextText("T003");
	nextTextAsChoice("T004", "YES", "NO");
	
	IF( lastSelectedChoiceIdxIs("0") )
		nextText("T005");
	ENDIF
	
	IF( lastSelectedChoiceIdxIs("1") )
		nextText("T006");
	ENDIF
	
	closeMessageWindow();
}
```

これはDataFile構文です。
PIは特殊なブロックで、NPCの個人情報を記述します。
speakerImageはメッセージウインドウ処理で表示する立ち絵的なもので、指定しなくてもよいです。
namedはtrueの場合、このNPCのIDがI18Nに存在し、speaker指定のメッセージウインドウでその名前が出ることを表します。falseまたは未定義の場合、名前はありません。
waTimeはspriteのWalkAnimationの1方向内のアニメーションの再生速度です。
sprioteは64*64ピクセルのSpriteSheetで、各4枚のアニメーションを上から南、北、東、西を向いているグラフィックを16*16ピクセルずつ定義します。
moveModelはNPCの移動ロジックで、以下の値を指定できます
・LOCKED：これはnpcListに記述された座標から動かないものです。
・ROUND,d,t：これはnpcListに定義された座標からdマスの距離までランダムに移動するものです。移動判定が行われる時間がtで、これは秒単位です。
　この秒の+-75%のランダムな時間おきにランダムな隣接する8マスに移動判定が行われ、移動先に移動可能な状態であれば、移動が行われ、そうでない場合はまた待機します。
 つまり1fとは1秒おきにこの判定が行われていることを示します。

TOUCHブロックは、スクリプトの部分で説明した通りで、PCがNPCに衝突したときに自動発動するイベントです。
TALKも同様で、会話する場合に実行するイベントです。

ブロック内を見て見ましょう。これはスクリプトです。
TOUCHでは、以下のコードを実行しています。
```
	openMessageWindow("T007").byMe();
	closeMessageWindow();
```
ScriptSystem#openMessageWindowは、会話を開始する指示で、引数で指定したIDのI18Nテキストを表示します。続くbyMeはこのNPCによる発言として名前と立ち絵をセットする任意の処理です。
ScriptSystem#closeMessageWindowは会話を終了してメッセージウインドウを閉じる処理です。
openMessageWindowとcloseMsssageWindowは会話の開始と終了に必須です。これらが片方だけ定義されている場合、スクリプトのロード時にエラーとなります。
つまり必ずセットで使用する必要があります。

次に、TALKを見て見ましょう。

 ```
	openMessageWindow("T001").byMe();


	nextText("T002");
	nextText("T003");
	nextTextAsChoice("T004", "YES", "NO");
	
	IF( lastSelectedChoiceIdxIs("0") )
		nextText("T005");
	ENDIF
	
	IF( lastSelectedChoiceIdxIs("1") )
		nextText("T006");
	ENDIF
	
	closeMessageWindow();
```
ScriptSystem#nextTextは現在すでに表示されているメッセージウインドウに別のテキストを設定するものです。ここでも、byMeのような立ち絵表示が起動できます。

ScriptSystem#nextTextAsChoiceは選択肢を表示するもので、最初の引数が問いかけ文、その後に最大5個の選択肢を表示できます。いずれもI18NTextです。
ScriptSystem#lastSelectedChoiceIdxIsは直前に実行されたnextTextAsChoiceで、何番目の選択肢が選ばれたかを調べるメソッドで、引数がintと解釈され、0から始まる選択肢のそれが選ばれていた場合にtrueになります。
これをIFの条件として利用して、該当する場合だけ特定のnextTextを実行することで、表示される文章を切り替えています。

このような仕掛けて、フラグのセットなどもできます。
フラグはFlagSystemを見てください。まだあまりテストしていませんが、大体使えるでしょう。


### ACTOR定義ファイル



